# -*- coding: utf-8 -*-
"""Q3-AI Assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E7osHfNm1lbCCx-ue5mCZxfjyy7QW0H4
"""

get_ipython().run_line_magic("pip", "install haversine")
# Haversine is used for distance between two points on a sphere

from haversine import haversine, Unit

import pandas as pd
import heapq

coorData = pd.read_csv("nodes.csv")

# function to get h(node)
def calculateHeuristic(currNode):
    [curLat, curLon] = coorData[coorData["id"] == currNode].iloc[0][
        ["lat", "lon"]
    ]
    cur = (curLat, curLon)
    dest = (17.240673, 78.432342)

    return haversine(cur, dest)

# For constructing graph from the distance matrix data
get_ipython().run_line_magic("pip", "install networkx")
import networkx as netX

graphData = pd.read_csv("distance_matrix.csv")
graphData = graphData[["source", "target", "length"]]

graphType = netX.Graph()
g = netX.from_pandas_edgelist(graphData, edge_attr="length", create_using=graphType)

# We will be using OpenSet as Heap
import heapq

# Function to create final coordinate route
def makePath(cameFrom, current):
    path = [current]
    while current in cameFrom.keys():
        current = cameFrom[current]
        path.insert(0, current)
    return path


# A* algorithm implementation
def aStar(srcNode, destNode):

    openSet = []

    cameFrom = {}
    cameFrom[srcNode] = None

    cost = {}
    cost[srcNode] = 0

    fScore = {}
    fScore[srcNode] = 0

    gScore = {}
    gScore[srcNode] = 0

    heapq.heappush(openSet, (srcNode, fScore))

    while len(openSet) > 0:

        current = heapq.heappop(openSet)

        if current[0] == destNode:
            return makePath(cameFrom, current[0])

        neighbourData = list(g.neighbors(current[0]))

        for item in neighbourData:
            neighbour = item
            distance = g[current[0]][neighbour]["length"]

            if neighbour not in cameFrom:

                cost[neighbour] = gScore[current[0]] + distance

                if cost[neighbour] < gScore.get(neighbour, float("inf")):
                    cameFrom[neighbour] = current[0]
                    gScore[neighbour] = cost[neighbour]
                    fScore[neighbour] = gScore[neighbour] + calculateHeuristic(
                        neighbour
                    )
                    if neighbour not in openSet:
                        heapq.heappush(openSet, (neighbour, fScore))

    return openSet

# Osm id of source node
source = 7065632060
# Osm id of destination node
destination = 5711258337

# Call aStar
route = aStar(source, destination)
route.pop(0)

# If path is not found
if len(route) == 0:
    print(f"Fatal Error: Path doesn't exist")

coorPath = []
for node in route:
    [lat, lon] = coorData[coorData["id"] == node].iloc[0][["lat", "lon"]]
    coorPath.append((lat, lon))

from statistics import mean

meanLat = mean(point[0] for point in coorPath)
meanLon = mean(point[1] for point in coorPath)

get_ipython().run_line_magic("pip", "install gmplot")
import gmplot

pathLats, pathLons = zip(*coorPath)
gmap = gmplot.GoogleMapPlotter(meanLat, meanLon, 10)
gmap.plot(pathLats, pathLons, "red", edge_width=3.0)
gmap.draw("shortest_route.html")